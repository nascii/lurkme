# Общее описание

Какого-либо идентификатора для человека на серверной стороне не предусмотрено. Предусмотрен идентификатор встречи 
и он временный, представляет из себя публичный ключ, генерируемый на время встречи.

Ключи сгенерирует приложение, предоставив публичный ключ в виде ссылки, которую можно будет отправить другим людям. 
Когда они по ней перейдут приложение автоматически подхватит ссылку и начнет ожидать координат с
устройства инициатора.

Контекст описания:
- Заходим в приложение
- Переходим на экран создания встречи

В это время приложение у Алисы: 
1. Генерирует пару ключей AlicePublic, AlicePrivate
2. Выводит свой публичный ключ в виде ссылки, которую можно расшарить
3. Подписывается на канал fingerprint(AlicePublic) на сервере

- 1, 2 просходит сразу при переходе на экран
- 3    происходит при нажатии на start

Подписавшись на канал ожидает в нем ключи от собеседников, они будут использованы как запросы на трекинг Алисы.

Алиса отправляет ссылку Бобу.

Теперь Боб. Он получает ссылку и открывает её, сразу видит отпечаток ключа Алисы.

В это время приложение Боба:
- Генерирует пару ключей BobPublic, BobPrivate
- Подписывается на канал fingerprint(BobPublic) на сервере
- Воссоздаёт AlicePublic из ссылки
- Отправляет в канал fingerprint(AlicePublic) ключ BobPublic

В итоге Алиса получает запрос на подписку(push уведомление?), получив публичный 
ключ Боба в свой инбокс, которым она будет шифровать gps координаты.

Если она одобряет этот запрос то в список ключей, которыми шифруются gps координаты Алисы будет добавлен ключ 
Боба, что в свою очередь означает что Боб сможет отслеживать положение Алисы. Никакого обратного взаимодействия 
не предусмотрено, Боб не узнает если Алиса отказала(наверное можно это как-то решить, но кажется что это в чем-то 
даже нормально и хорошо в плане приватности).

Видно что получение ключей состоит в возможности подписки на канал на сервере.
Чтобы закрыть возможную дырку для подписки на канал нужно доказать владение приватным ключем для указанного 
fingerprint(publickey). Для этого сервер запросит его публичный ключ, зашифрует им строку, известную только серверу и 
попросит её расшифровать и вернуть ответ, в зависимости того, равна ли полученная строка задуманной сервером будет 
сделан вывод о возможности подписки.

Вернемся к Алисе. Она уже получила уведомление о том что Боб хочет отслеживать её gps координаты и 
подтвердила его(а может быть он подтвердился автоматически? почему бы и нет, но ссылку надо защищать пуще прежнего).

Приложение получив заинтересованного Боба в свои подписчики начинает запрашивать геолокационные данные у 
устройства. Каждый раз геолокационные данные шифруются списком публичных ключей подписчиков и отправляются
на сервер в инбоксы по ключу fingerprint(publickey), т.е. как бы рассылает обновление адресатам.

Когда сервер получает обновление данных по ключу он триггерит push уведомление, в котором сообщается
что данные по его ключу изменились(на самом деле структура может быть сложнее, ну малоли, мы не только gps
хотим обмениваться или ещё что-то такое, но для простоты я решил не накручивать особо :) ).
Таким образом все подписавшиеся узнают о изменении геолокации, т.е. Боб узнает об изменении позиции Алисы.

Далее в зависимости от близости точек "текущее местоположение gps с телефона" и "полученные от сервера данные"
выводим холодно/горячо.

# Интерфейс
## Главный экран

Две кнопки:
- Активировать приглашение
- Создать встречу

## Экран "Активировать приглашение"

Поле для ввода текста, пояснение, что в поле ввода требуется 
вставить код приглашения, и кнопка "ОК"

## Экран "Создать встречу"

Текстом отображен ссылка-инвайт.

Кнопка "Старт" и "Отмена".

# Логика
## Главный экран

При тапе по кнопкам - "Активировать приглашение" и "Создать встречу" 
переходим на одноименные экраны.

# Ссылки
- https://github.com/transistorsoft/react-native-background-geolocation
